use strict;

my $argNum = scalar @ARGV;
my $type = $ARGV[0];
my $in = $ARGV[1];
my $mapping = $ARGV[2];
#my $out = $ARGV[3];

#read in the mapping file
my %mapping;
#open IN,"mapping.tsv";
open IN,"$mapping";
<IN>;#skip the header line
while(my $line=<IN>){
	chomp($line);
	my ($newHeader, $original) = split("\t",$line);
	$newHeader = substr($newHeader,1) if ($newHeader =~ /^>/);
	$original = substr($original,1) if ($original =~ /^>/);
	$mapping{$newHeader}=$original;
}
close IN;
#calculate the pattern
#as the mapping is generated by header manipulation serial option in the format of prefix_serial
my @pattern = keys %mapping;
my $tmp = $pattern[0];
my $idx = rindex($tmp,"_");
my $prefix = substr($tmp,0,$idx);
my $pattern = "${prefix}_\\d+";
#print "$prefix\n$pattern\n";

if ($type == 1){ # GMAP result
	&replaceTSV("$in",0,"@",0); # Each header line begins with character `@' followed by a two-letter record type code.
}elsif ($type == 2){ # Extract Hits result
	&replaceTSV("$in",1,"",1); # first line is header, second column is for protein
}elsif ($type == 3){ # PIT:Integrate GFF3 result
	&replaceTSV("$in",8,"#",0); #lines beginning with a single '#' are used for human-readable comments, Lines beginning with '##' are directives
}elsif ($type == 4){ # PIT:Integrate ORF result
	&replaceFasta("$in");
}
#&replaceTSV("extractedHits.tsv",1,"",3);
#first the file needs replacing
sub replaceTSV(){
	my ($file,$col,$comment,$skip) = @_;
	my $separator = "\t";
	open IN, "$file";
	my $line;
	my $count = 0;
	while ($line = <IN>){
		$count ++;
		unless ($count>$skip) {
			print $line;
			next;
		}
		if (substr($line,0,1) eq $comment){
			print $line;
			next;
		}
		chomp ($line);
		my @elmt = split($separator,$line);
		my $target = $elmt[$col];
		$elmt[$col] = &replace($target);
		my $newLine = join ($separator,@elmt);
		print "$newLine\n";
	}
}

sub replaceFasta(){
	my $file = $_[0];
	open IN, "$file";
	while(my $line = <IN>){
		if ($line=~/^>/){
			chomp($line);
			my $result = &replace($line);
			print "$result\n";
		}else{
			print $line;
		}
	}
}

sub replace(){
	my $target = $_[0];
	my $result = "";
	#print "Original: $target\n";
	while ($target =~/$pattern/){
		$result .= "$`$mapping{$&}";
		$target = "$'";
		#$target = "$`$mapping{$&}$'"; # should not be used in this way to avoid the bug when new header is part of old header which could cause dead loop
		#print "new result: $result\n";
		#print "new target: $target\n";
	}
	$result .= $target;
	return $result;
}
		
sub usage(){
	print "Usage: perl fastaheaderManipulation.pl <fasta file> <reg exp index> [reg exp|prefix] [mapping file]\n\n";
	print "fasta file is the file you want to change the header\n\n";
	print "regular expression index:\n1 for everything after > i.e. no change\n";
	print "2 for up to first white space\n3 for NCBI gi accession\n4 for Uniprot accession e.g. P01024\n";
	print "5 for up to first \\ or |\n6 for IPI accession\n";
	print "0 for user-defined regular expression which is expected as the third parameter\n";
	print "-1 for directly replace the original header with the artificial header in the format of prefix_serial\n\n";
	print "mapping file is the tab-separated file to store the mapping between the original header and the generated header\n";
	exit;
}